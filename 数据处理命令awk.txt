1.awk的简介：
    awk是一个非常强大的数据处理命令，支持条件判断，数组，循环等功能，与grep，sed被称为linux三剑客

2.awk的应用场景：
    通常对数据进行列的提取
    列的提取，虽然使用cut命令也可以做到，但是cut命令必须指定分隔符才能完整的完成命令。而Linux系统中许多
其他命令是不使用同一的分隔符的，而awk命令可以更智能的提取出这些自然列。同时awk有许多其他优化输出命令，比
cut命令更加强大。

3.awk的语法
    akw '条件1 {执行动作} 条件2 {执行动作}...' 文件名 
 或 awk [选项] '条件1 {执行动作} 条件2 {执行动作...}' 文件名
    注意事项：
        ① 条件、执行动作可以有多组，也可以有一组
        ② 对于一组的条件、执行动作，可以省略条件和执行动作，但是要注意省略执行动作没有意义
        ③ 假若条件1有多个条件，要用()括起来
        ④ 条件中写布尔表达式，如(NR >=1 && NR <= 5)；也可以使用BEGIN、END这样的执行时机

 4.awk的特殊符号和选项
    ① 执行动作：
        printf #格式化输出，不会自动换行，类似于C语言中的用法。也可以直接使用类似 <printf "输出内容"> 这样的用法
            %s #代表字符串，用于printf中的占位符
            \t #制表符
            \n #换行符
            eg. printf '%s\t%s\t%s\t%s\t%s\t%s\t' 1 2 3 4 5 6 #awk中不怎么用这个命令，且包住占位符的单引号可以不加(CentOS7)

        print #打印出内容，默认会自动换行

    ② 特殊符号
        NR  #行号，代表当前行号，具体看例子(注意是行号，不是列);awk中的行从1开始
        $1  #代表第一列;awk中的列从1开始
        $2  #代表第二列
        $n  #写具体的列，参考$1、$2
        $NF #代表最后一列   
        BEGIN #指定在读取所有行内容前执行的命令,一般用来初始化操作 awk 'BEGIN {}' {}中的内容会执行一次
        END #指定在结束的时候执行的命令

    ③ 选项
        -F #指定分隔符

5.示例

    使用df -h命令，作为参考
    ---------------------------------------------------------------------
      文件系统                 1M-块  已用  可用  已用% 挂载点            
    |devtmpfs                  898     0   898    0%   /dev             |
    |tmpfs                     910     0   910    0%   /dev/shm         |
    |tmpfs                     910    10   901    2%   /run             |
    |tmpfs                     910     0   910    0%   /sys/fs/cgroup   |
    |/dev/mapper/centos-root 37862  2527 35336    7%   /                |
    |/dev/sda1                1014   150   865   15%   /boot            |
    |tmpfs                     182     0   182    0%   /run/user/0      |
    ---------------------------------------------------------------------
    ① df -h | awk 'NR==6 {print $3}' #输出第四行的第一列数据，输出为2527 (对于输出，表头也算一行)

    ② df -h | awk '(NR >=2 && NR <= 5) {print $1}' #输出第2行至第5行的第一列数据，即输出devtmpfs
                                                                                     tmpfs
                                                                                     tmpfs
                                                                                     tmpfs
    ③ df -h | awk '{print $NF}' # 输出每一行的最后一列（注意这个例子省略了条件）

    ④ cat /etc/passwd | awk 'BEGIN {FS=":"} {print $1}' #在开始读取每行前指定分隔符为冒号，然后输出每一行第一列
        BEGIN {FS=":"} 提前指定使用:作为分隔符，注意这里的用法与awk -F ":"无关

    ⑤ df -h | grep -v '文件系统' | awk '{printf $1} {printf "文件系统使用率："} {print $5}'
        df -h #查看目前在系统上的文件系统的磁盘使用情况统计。-h表示使用人类可读的格式(预设值是不加这个选项的...)
        grep -v '文件系统' #将含有文件系统的那行输出过滤，相当于去掉第一行表头,起到过滤而不是查找作用的是-v选项
        此外，在这个例子中可以看到，awk后跟着的''中的内容，并没有严格按照 <条件 {执行动作}>...这样的格式。因此在使用的时候我们也可以根据实际情况来
    输出合适的内容
        命令执行输出结果：
            devtmpfs文件系统使用率：0%
            tmpfs文件系统使用率：0%
            tmpfs文件系统使用率：2%
            tmpfs文件系统使用率：0%
            /dev/mapper/centos-root文件系统使用率：7%
            /dev/sda1文件系统使用率：15%
            tmpfs文件系统使用率：0%
    
    ⑥ df -h |grep -v '文件系统' | awk 'BEGIN {printf "文件系统使用情况：\n \n"} {printf $1} {printf "文 件系统使用率："} {print $5}'
        注意这个例子跟⑤的区别在于加入了BEGIN {printf "文件系统使用情况：\n \n"}，注意这是一个组合，BEGIN后面跟着的{}内容只会在读取前执行一次，
    而不是读取每一行是都会执行。
        命令执行输出结果：
            文件系统使用情况：
            
            devtmpfs文 件系统使用率：0%
            tmpfs文 件系统使用率：0%
            tmpfs文 件系统使用率：2%
            tmpfs文 件系统使用率：0%

    ⑦ df -h |grep -v '文件系统' | awk 'BEGIN {printf "文件系统使用情况：\n \n"} END {printf "一切正常 \n"} {printf $1} {printf "文件系统使用率："} {print $5}'
        注意这个例子跟⑥的区别在于加入了END {printf "一切正常 \n"}，输出结果会在最后一行打印“一切正常”，且我们可以发现BEGIN {}和END {}所在的位置并
    不影响他们执行的时机。
        命令执行输出结果：
            文件系统使用情况：
            
            devtmpfs文件系统使用率：0%
            tmpfs文件系统使用率：0%
            tmpfs文件系统使用率：2%
            tmpfs文件系统使用率：0%
            /dev/mapper/centos-root文件系统使用率：7%
            /dev/sda1文件系统使用率：15%
            tmpfs文件系统使用率：0%
            一切正常 

    ⑧ awk -F ":" '{print $1}' /etc/passwd #指定分隔符为“:”，（指定后不会使用其他的分割逻辑），并输出每一行的第一列

6.其他应用
    ① 使用awk直接杀掉tomcat（等可被唯一定位或循环）的进程
        前置准备：kill -9 $()指kill -9命令会使用$()中命令的结果作为参数

        下面三条命令的作用相同，只是写法或原理不同
        kill -9 $(ps -ef|grep tomcat|awk '$8 != "grep" {print $2}')
        kill -9 $(ps -ef|grep tomcat|grep -v grep|awk '{print $2}')
        ps -ef|grep tomcat | grep -v grep|awk '{print $2}'|xargs kill -9
        


    